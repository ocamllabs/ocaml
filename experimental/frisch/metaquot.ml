(* A -ppx rewriter to be used to write Parsetree-generating code
   (including other -ppx rewriters) using concrete syntax.

   See metaquot_test.ml for an example.

   We support the following extensions in expression position:

   [%expr ...]  maps to code which creates the expression represented by ...
   [%pat "..."] maps to code which creates the pattern represented by ...
   [%pat "..."] maps to code which creates the pattern represented by ...
   [%str ...] maps to code which creates the structure represented by ...
   [type "..."] maps to code which creates the core type represented by ...

   Note that except for the expr and str expander, the argument needs to be
   a string literal (it can also be a quoted string, of course), which
   will be re-parse by the expander (in case of a parsing error,
   the location will be relative to the parsed string).

   Quoted code can refer to expressions representing AST fragments,
   using the following extensions:

     [%e ...] where ... is an expression of type Parsetree.expression
     [%t ...] where ... is an expression of type Parsetree.core_type
     [%p ...] where ... is an expression of type Parsetree.pattern


   All locations generated by the meta quotation are by default set
   to Location.none.  This can be overriden by providing a custom
   expression which will be inserted whereever a location is required
   in the generated AST.  This expression can be specified globally
   (for the current structure) as a structure item attribute:

     ;;[@@metaloc ...]

   or locally for the scope of an expression:

     e [@metaloc ...]

   No support is provided for meta quotation in pattern position.
*)

module Main : sig end = struct
  open Asttypes
  open Parsetree
  open Ast_helper
  open Ast_helper.Convenience

  let prefix ty s =
    let open Longident in
    match parse ty with
    | Ldot(m, _) -> String.concat "." (Longident.flatten m) ^ "." ^ s
    | _ -> s

  class exp_builder =
    object
      method record ty x = record (List.map (fun (l, e) -> prefix ty l, e) x)
      method constr ty (c, args) = constr (prefix ty c) args
      method list = list
      method tuple = tuple
      method int = int
      method string = str
      method char = char
      method int32 x = Exp.constant (Const_int32 x)
      method int64 x = Exp.constant (Const_int64 x)
      method nativeint x = Exp.constant (Const_nativeint x)
    end


  let get_exp loc = function
    | PStr [ {pstr_desc=Pstr_eval (e, _); _} ] -> e
    | _ ->
        Format.eprintf "%aExpression expected@."
          Location.print_error loc;
        exit 2

  let get_typ loc = function
    | PTyp t -> t
    | _ ->
        Format.eprintf "%aType expected@."
          Location.print_error loc;
        exit 2

  let get_pat loc = function
    | PPat (t, None) -> t
    | _ ->
        Format.eprintf "%aPattern expected@."
          Location.print_error loc;
        exit 2

  let lifter loc =
    object
      inherit [_] Ast_lifter.lifter as super
      inherit exp_builder

          (* Special support for location in the generated AST *)
      method! lift_Location_t _ = loc

          (* Support for antiquotations *)
      method! lift_Parsetree_expression = function
        | {pexp_desc=Pexp_extension({txt="e";loc}, e); _} -> get_exp loc e
        | x -> super # lift_Parsetree_expression x

      method! lift_Parsetree_pattern = function
        | {ppat_desc=Ppat_extension({txt="p";loc}, e); _} -> get_exp loc e
        | x -> super # lift_Parsetree_pattern x

      method! lift_Parsetree_core_type = function
        | {ptyp_desc=Ptyp_extension({txt="t";loc}, e); _} -> get_exp loc e
        | x -> super # lift_Parsetree_core_type x
    end

  let loc = ref (evar "Location.none")
  let handle_attr = function
    | {txt="metaloc";loc=l}, e -> loc := get_exp l e
    | _ -> ()

  let with_loc ?(attrs = []) f =
    let old_loc = !loc in
    List.iter handle_attr attrs;
    let r = f () in
    loc := old_loc;
    r

  let report_error ppf exn =
    let report ppf = function
      | Lexer.Error(err, loc) ->
          Location.print_error ppf loc;
          Lexer.report_error ppf err
      | Syntaxerr.Error err ->
          Syntaxerr.report_error ppf err
      | x ->
          Format.fprintf ppf "%s" (Printexc.to_string x)
    in
    Format.fprintf ppf "@[%a@]@." report exn

  let extract_str parse kind = function
    | {pexp_desc = Pexp_constant (Const_string (s, _)); pexp_loc = loc; _} ->
        begin try parse (Lexing.from_string s)
        with exn ->
          Location.print_error Format.std_formatter loc;
          Format.eprintf "Error while parsing a %s quotation:@.%a@." kind
            report_error exn;
          exit 2
        end
    | {pexp_loc = loc; _} ->
        Location.print_error Format.std_formatter loc;
        Format.eprintf
          "The content of this quotation must be a string literal.@.";
        exit 2

  let expander = object
    inherit Ast_mapper.mapper as super

    method! expr e =
      with_loc ~attrs:e.pexp_attributes
        (fun () ->
          match e.pexp_desc with
          | Pexp_extension({txt="expr";loc=l}, e) ->
              (lifter !loc) # lift_Parsetree_expression (get_exp l e)
          | Pexp_extension({txt="pat";loc=l}, e) ->
              (lifter !loc) # lift_Parsetree_pattern (get_pat l e)
          | Pexp_extension({txt="str";_}, PStr e) ->
              (lifter !loc) # lift_Parsetree_structure e
          | Pexp_extension({txt="type";loc=l}, e) ->
              (lifter !loc) # lift_Parsetree_core_type (get_typ l e)
          | _ ->
              super # expr e
        )

    method! structure l =
      with_loc
        (fun () -> super # structure l)

    method! structure_item x =
      begin match x.pstr_desc with
      | Pstr_attribute x -> handle_attr x
      | _ -> ()
      end;
      super # structure_item x
  end

  let () = Ast_mapper.main expander
end
